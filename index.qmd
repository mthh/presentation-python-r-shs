---
title: "Analyse comparative Python / R pour les SHS"
author: "Matthieu Viry"
subtitle: 16 mai 2023
format:
  revealjs:
    embed-resources: true
css: ['style.css']
prefer-html: true
---

```{python}
#! cache: true
import pandas as pd
print("aaa")
```

# Introduction

## Pourquoi comparer Python et R

-

# Historique et comparaison des langages sur le papier...

## Python

- Langage créé à la fin des années 80 - première version publique sortie en 1991.

- 


## R

## Python

## R

# Présentation comparée des écosystèmes

## Fonctionnalités natives / Python

## Fonctionnalités natives / R


## Packages additionnels / Python

**PyPI** (Python Package Index) :

## Packages additionnels / R

**CRAN** : index de packages supervisé

## Documentation / Python

Un point fort de Python est sa documentation officielle, qui contient tout le nécessaire pour utiliser le langage de manière proactive (tutoriel, référence de l'ensemble des fonctions / objets de tous les modules de la bibliothèque standard, etc.) et qui est mise à disposition dans plusieurs langues (Anglais, Français, Espagnol, Coréen, Japonais, Chinois, etc.)

## Documentation / R

La documentation de R, tout aussi complète qu'elle soit est moins *user-friendly* et n'est disponible qu'en anglais.

# En terme de syntaxe ça donne quoi ?

## Python et l'indentation du code...

<br>

```{python}
#| error: true
#| echo: true
#| message: true
#| cache: true
my_list = [1, 2, 3]

for item in my_list:
    if item % 2 == 0:
        print('even')
    else:
    print('odd')
```

## Python et l'indentation du code...

<br>

```{python}
#| error: true
#| echo: true
#| message: true
#| cache: true
my_list = [1, 2, 3]

for item in my_list:
    if item % 2 == 0:
        print('even')
    else:
        print('odd')
```

## Python et l'indentation du code...

- Respecter les règles d'identations est nécessaire (comprendre *obligatoire*) en Python.

- Ce n'est pas une *contrainte* lors d'une session de travail car les IDE guident la position du curseur.

- Cette indentation a un rôle direct sur le contrôle du flux d'éxecution.

- Elle permet notamment d'éviter l'utilisation d'accolades (*curly brackets*) pour délimiter les blocs et de point-virgules pour délimiter les instructions.

## Python et l'indentation du code...

<br>

Le code qui suit est volontairement incorrect mais ne génère pas d'erreur lors de l'éxecution :

```{python}
#| echo: true
li1 = [1, 2, 3, 4, 5, 6]
li2 = [4, 20, 31, 87, 123, 621]

# Additionnons les deux listes, éléments par éléments,
# et stockons chaque résultat dans une nouvelle liste
result = []

for item1, item2 in zip(li1, li2):
    new_item = item1 + item2
result.append(new_item)

print(result)
```

## Python et l'indentation du code...

<br>

Une fois l'indentation corrigée...

```{python}
#| echo: true
li1 = [1, 2, 3, 4, 5, 6]
li2 = [4, 20, 31, 87, 123, 621]

# Additionnons les deux listes, éléments par éléments,
# et stockons chaque résultat dans une nouvelle liste
result = []

for item1, item2 in zip(li1, li2):
    new_item = item1 + item2
    result.append(new_item)

print(result)
```

## R, accolades et `pipe`s

À l'inverse de Python, R utilise des accolades pour délimiter les blocs d'instructions et ne se soucie donc par de l'indentation (on veillera quand même être cohérent afin de faciliter la lecture du code)

```{r}
#| echo: true
my_list <- list(1, 2, 3)

for (item in my_list) {
  if (item %% 2 == 0) {
    print("even")
  } else {
    print("odd")
  }
}
```

## R, accolades et `pipe`s

R propose par ailleurs un opérateur `pipe` pour enchaîner les commandes, permettant ainsi
de remplacer une expression telle que 

```{r}
#| echo: true
exp(sqrt(log(12, base = 10)))
```

par 

```{r}
#| echo: true
12 |> log(base = 10) |> sqrt() |> exp()
```

::: {.notes}
Il s'agit d'une question de gout, et ça dépend aussi des expressions à enchaîner...dans l'exemple actuel je préfère la version sans l'opérateur pipe, que je trouve non ambigue et facilement lisible par un public venant de n'importe quel langage...
:::

# *Data structures* natives

:::{.small}
*Les structures de données sont les éléments fondamentaux autour desquels vous construisez vos programmes. Chaque structure de données fournit une manière particulière d'organiser les données afin d'y accéder efficacement.*
:::

## Python

Python est livré avec un ensemble complet de structures de données dans sa bibliothèque standard : `dict` (tableau associatif), `tuple` (un conteneur immuable), `list` (tableau dynamique mutable), `array` (tableau typé de base), etc.


```{python}
#| echo: true
my_dict = { 'john': 32, 'jane': 27, 'jack': 30 }
```


## Python *(classes)*

Comme il s'agit d'un langage orienté-objet, il est également possible de définir des classes, permettant de facilement modéliser des catégories d'objets...

```{python}
#| echo: true
class Point:
    def __init__(self, x, y):
      self.x = x
      self.y = y

    def distance(self, other):
      return (
        (other.x - self.x) ** 2 + (other.y - self.y) ** 2
      ) ** 0.5
```

## Python *(classes)*

Instanciation et utilisation :

```{python}
#| echo: true
p1 = Point(2, 6)
p2 = Point(9, 9)

print('Distance = ', p1.distance(p2))
```



## R


# La syntaxe c'est bien... et la sémantique qui y est associée ?

## R

Sémantique *copy-on-modify* :

```{r}
my_list <- c(1, 2, 5)
other_list <- my_list
# Pour l'instant 'other_list' et 'my_list' pointent vers le même objet..

# Modifions un élément de 'other_list'..
other_list[3] <- 11
# une copie de 'my_list' a été faite, son 3 élément a été modifié puis 'other_list' s'est mis à pointer vers cette copie

print(my_list)
print(other_list)
```

Pour en savoir plus sur ce point [*Advanced R* (Hadley Wickham)](https://bookdown.dongzhuoer.com/hadley/adv-r/copy-on-modify.html)

## Python

Sémantique *pass-by-assignment* et différence en types muables et immuables :

```{python}
# le type list est muable
a = [1, 3, 5]
b = a # 'a' et 'b' pointent vers le même objet

b[2] = 11 # Modifie l'objet vers lequel pointe 'b' qui est également celui vers lequel pointe 'a'
```

```{python}
i = 5 # les entiers sont immuables
j = i
i = i + 1 # la valeur 5 ne peut pas être modifiée, un nouvel objet est créé ici

print(i) # 6
print(j) # 7
```

Pour en savoir plus sur ce point : [Documentation officielle -  Questions fréquemment posées sur Python](https://docs.python.org/fr/3/faq/programming.html#why-did-changing-list-y-also-change-list-x)

## Load the data

Load the data from the [#TidyTuesday](https://github.com/rfordatascience/tidytuesday/blob/master/data/2021/2021-08-24/readme.md) repository:

```{r}
#| label: read-data
#| echo: true
#| message: false
#| cache: true
lemurs <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-08-24/lemur_data.csv')
```
## Data wrangling

Filter the data to only look at adult male Collared Brown Lemurs, and extract only the age and weight columns:

```{r}
#| label: wrangling
#| echo: true
#| message: false
#| output-location: slide
library(dplyr)
library(knitr)
lemur_data <- lemurs %>% 
  filter(taxon == "ECOL",
         sex == "M",
         age_category == "adult") %>% 
  select(c(age_at_wt_mo, weight_g)) %>% 
  rename(Age = age_at_wt_mo, 
         Weight = weight_g)
kable(head(lemur_data))
```

## Modelling

Fit a linear model using Python:

```{python}
#| label: modelling
#| echo: true
#| message: false
lemur_data_py = r.lemur_data

import statsmodels.api as sm
y = lemur_data_py[["Weight"]]
x = lemur_data_py[["Age"]]
x = sm.add_constant(x)
mod = sm.OLS(y, x).fit()
lemur_data_py["Predicted"] = mod.predict(x)
lemur_data_py["Residuals"] = mod.resid
```

## Plot the residuals

```{r}
#| label: plotting
#| echo: true
#| output-location: slide
#| message: false
#| fig-align: center
#| fig-alt: "Scatter plot of predicted and residual values for the fitted linear model."
library(reticulate)
library(ggplot2)
lemur_residuals <- py$lemur_data_py
ggplot(data = lemur_residuals,
       mapping = aes(x = Predicted,
                     y = Residuals)) +
  geom_point(colour = "#2F4F4F") +
  geom_hline(yintercept = 0,
             colour = "red") +
  theme(panel.background = element_rect(fill = "#eaf2f2",
                                        colour = "#eaf2f2"),
        plot.background = element_rect(fill = "#eaf2f2",
                                       colour = "#eaf2f2"))
```

## A

:::: {.columns}

::: {.column width="50%"}

#### Depuis R

```{r}
#| echo: true
library(dplyr)
library(readr)

chipo <- read_tsv(
    'https://raw.githubusercontent.com/justmarkham/DAT8/master/data/chipotle.tsv')

head(chipo)
```

:::

::: {.column width="50%"}


#### Depuis Python

```{python}
#| echo: true
import pandas as pd
pd.set_option('display.max_columns', 5)

chipo = pd.read_csv(
    'https://raw.githubusercontent.com/justmarkham/DAT8/master/data/chipotle.tsv',
    sep = '\t',
)

chipo.head().to_html()
```

:::

::::


Plusieurs éléments peuvent être notés dès maintenant,
que ce soit concernant l'import des bibliothèques utilisées que concernant le
type de programmation mis en oeuvre dans les deux langages.

La syntaxe de R est plutôt *fonctionnelle* alors que la syntaxe de python est plutôt *orientée-objet* (on dit d'ailleurs souvent que tout est *objet* en Python).


## Quoi retenir ?



- R a plus de fonction natives dédiés à la statistique

- Python a ... alors que R a ...

- De manière générale, R est meilleur pour les statistiques
(ça ne veut pas dire que Python est mauvais pour autant ;))

- Il est généralement plus simple de faire des tâches non-statistiques en Python

- Voir https://www.tiobe.com/tiobe-index/

## Conclusion

Utiliser le langage qui vous plait le plus... prendre du plaisir en développant est important !
